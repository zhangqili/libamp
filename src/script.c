/*
 * Copyright (c) 2026 Zhangqi Li (@zhangqili)
 *
 * SPDX-License-Identifier: GPL-3.0-or-later
 */
#include "script.h"
#include "stdio.h"

#include "cutils.h"
#include "mquickjs.h"
#include "mqjs_utils.c"

#include "mqjs_stdlib.h"
void script_log_func(void *opaque, const void *buf, size_t buf_len) {
    fwrite(buf, 1, buf_len, stdout);
}
extern const JSSTDLibraryDef js_stdlib;

#define JS_MEMORY_SIZE  (2 * 1024)
uint8_t js_memory_pool[JS_MEMORY_SIZE];

uint8_t app_bin[] = {  0xfb, 0xac, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00,
  0x4d, 0x00, 0x00, 0x00, 0x36, 0x03, 0x00, 0x00, 0x3c, 0x65, 0x76, 0x61,
  0x6c, 0x3e, 0x00, 0x61, 0xb6, 0x01, 0x00, 0x00, 0x6c, 0x6f, 0x67, 0x00,
  0xb6, 0x03, 0x00, 0x00, 0x63, 0x6f, 0x6e, 0x73, 0x6f, 0x6c, 0x65, 0x00,
  0x3a, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x15, 0x00, 0x00, 0x00,
  0x0d, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x80, 0x26, 0x05, 0x00, 0x00, 0x2e, 0x2f, 0x69, 0x6e,
  0x70, 0x75, 0x74, 0x2e, 0x6a, 0x73, 0x00, 0x00, 0x48, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x00, 0x00, 0xa1, 0x00, 0x00, 0x00, 0x89, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x75, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00,
  0x3d, 0x00, 0x00, 0x00, 0xdd, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x4a, 0x00, 0x00, 0x00, 0x3b, 0x0d, 0x00, 0x00, 0x02, 0x00, 0x06, 0x00,
  0x15, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x2a, 0x00, 0x00, 0x00,
  0x0d, 0x00, 0x00, 0x00, 0x95, 0x00, 0x00, 0x00, 0xa6, 0x02, 0x00, 0x00,
  0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x00, 0x00, 0x00, 0x8c, 0x03, 0x00, 0x00,
  0x5f, 0x33, 0x00, 0x00, 0x30, 0x00, 0x00, 0x64, 0x50, 0x34, 0x20, 0x00,
  0x00, 0x00, 0x30, 0x01, 0x00, 0x21, 0x00, 0x00, 0x02, 0x01, 0x00, 0x30,
  0x00, 0x00, 0x1a, 0x02, 0x00, 0x0d, 0x30, 0x00, 0x00, 0x40, 0x31, 0x00,
  0x00, 0x36, 0xde, 0xff, 0xff, 0xff, 0x30, 0x01, 0x00, 0x21, 0x00, 0x00,
  0x30, 0x00, 0x00, 0x1a, 0x01, 0x00, 0x0d, 0x1d, 0x2c, 0x01, 0x00, 0x00,
  0xe1, 0x38, 0xfe, 0x5e, 0x15, 0x8f, 0xe1, 0xb8, 0x4b, 0x82, 0x0b, 0xae,
  0x0e, 0x63, 0xe2, 0xeb, 0xc0, 0x00, 0x00, 0x00};
size_t app_bin_len = 260;

static void dump_error(JSContext *ctx)
{
    JSValue obj;
    obj = JS_GetException(ctx);
    JS_PrintValueF(ctx, obj, JS_DUMP_LONG);
}

static JSContext *js_ctx;
void script_init(void)
{
    JSValue val;
    js_ctx = JS_NewContext(js_memory_pool, sizeof(js_memory_pool), &js_stdlib);
    if (!js_ctx) {
        return;
    }
    JS_SetLogFunc(js_ctx, script_log_func);
    //if (JS_IsBytecode(app_bin, app_bin_len)) {
    //    if (JS_RelocateBytecode(js_ctx, app_bin, app_bin_len) != 0) {
    //        fprintf(stderr, "Could not relocate bytecode\n");
    //        return;
    //    }
    //    val = JS_LoadBytecode(js_ctx, app_bin);
    //} else {
    //    printf("not valid bytecode\n");
    //    return;
    //}
    char code[] ="var x = 1;function fun1(){console.log(x+=1);}setTimeout(fun1, 1000);setTimeout(fun1, 2000);setTimeout(fun1, 3000);setTimeout(fun1, 4000);console.log('waiting...');";
    val = JS_Parse(js_ctx, (char *)code, sizeof(code), "", FALSE);
    if (JS_IsException(val)) {
        dump_error(js_ctx);
    }
    JSValue ret = JS_Run(js_ctx, val);
    
    if (JS_IsException(ret)) {
        dump_error(js_ctx);
    }
    //JS_FreeContext(ctx);
}

static void run_timers(JSContext *ctx)
{
    int64_t min_delay, delay, cur_time;
    BOOL has_timer;
    int i;
    JSTimer *th;
    min_delay = 1000;
    cur_time = get_time_ms();
    has_timer = FALSE;
    for(i = 0; i < MAX_TIMERS; i++) {
        th = &js_timer_list[i];
        if (th->allocated) {
            has_timer = TRUE;
            delay = th->timeout - cur_time;
            if (delay <= 0) {
                JSValue ret;
                /* the timer expired */
                if (JS_StackCheck(ctx, 2))
                    goto fail;
                JS_PushArg(ctx, th->func.val); /* func name */
                JS_PushArg(ctx, JS_NULL); /* this */
                
                JS_DeleteGCRef(ctx, &th->func);
                th->allocated = FALSE;
                
                ret = JS_Call(ctx, 0);
                if (JS_IsException(ret)) {
                fail:
                    dump_error(js_ctx);
                    return;
                }
                min_delay = 0;
                break;
            } else if (delay < min_delay) {
                min_delay = delay;
            }
        }
    }
    if (!has_timer)
        return;
}

void script_process(void)
{
    run_timers(js_ctx);
}

void script_event_handler(KeyboardEvent event)
{
    switch (event.event)
    {
    case KEYBOARD_EVENT_KEY_DOWN:
        break;
    case KEYBOARD_EVENT_KEY_TRUE:
        break;
    case KEYBOARD_EVENT_KEY_UP:
        break;
    case KEYBOARD_EVENT_KEY_FALSE:
        break;
    default:
        break;
    }
}